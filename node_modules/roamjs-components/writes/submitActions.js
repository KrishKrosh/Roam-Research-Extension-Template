"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const date_fns_1 = require("date-fns");
const ProgressDialog_1 = require("../components/ProgressDialog");
const uuid_1 = require("uuid");
const actionQueue = [];
const submittedActions = {};
let nextProcess = 0;
const ROAM_LIMIT = 300;
const ROAM_TIMEOUT = 61000; // One minute, plus an extra second to be safe.
const log = (detail) => {
    const element = document.getElementById("roamjs-progress-dialog-root");
    if (element) {
        element.dispatchEvent(new CustomEvent("log", { detail }));
        return undefined;
    }
    else {
        return (0, ProgressDialog_1.render)(detail);
    }
};
const submitActions = (actions) => {
    actionQueue.push(...actions.map((a) => (Object.assign(Object.assign({}, a), { uuid: (0, uuid_1.v4)() }))));
    let close = undefined;
    const processActions = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const capacity = ROAM_LIMIT - Object.keys(submittedActions).length;
        actionQueue
            .slice(0, capacity)
            .forEach(({ uuid }) => (submittedActions[uuid] = undefined));
        if (capacity > 0) {
            const submitNow = actionQueue.splice(0, capacity);
            yield Promise.all(submitNow.map((action) => {
                const { params, type, uuid } = action;
                return window.roamAlphaAPI[type](params)
                    .catch((e) => {
                    console.error(`Failed action of type ${type} with params:`);
                    console.error(params);
                    console.error(`Here's the error:`);
                    console.error(e);
                })
                    .then(() => {
                    submittedActions[uuid] = { action, date: new Date() };
                });
            }));
        }
        const submittedActionsEntries = Object.entries(submittedActions).filter(([, v]) => !!v);
        if (submittedActionsEntries.length && !nextProcess) {
            const maxDateEntered = new Date(submittedActionsEntries
                .map(([, a]) => (a ? a.date.valueOf() : 0))
                .reduce((p, c) => (c > p ? c : p), 0));
            const timeout = ROAM_TIMEOUT - (0, date_fns_1.differenceInMilliseconds)(new Date(), maxDateEntered);
            if (!actionQueue.length)
                close === null || close === void 0 ? void 0 : close();
            else {
                const rendered = log({
                    timeout: Math.ceil(timeout / 1000),
                    actionQueueLength: actionQueue.length,
                });
                if (rendered)
                    close = rendered;
                const interval = window.setInterval(() => {
                    log({
                        timeout: Math.ceil((ROAM_TIMEOUT -
                            (0, date_fns_1.differenceInMilliseconds)(new Date(), maxDateEntered)) /
                            1000),
                    });
                }, 1000);
                nextProcess = window.setTimeout(() => {
                    window.clearInterval(interval);
                    submittedActionsEntries.forEach(([k]) => {
                        delete submittedActions[k];
                    });
                    nextProcess = 0;
                    processActions();
                }, timeout);
            }
        }
    });
    return processActions();
};
exports.default = submitActions;
//# sourceMappingURL=submitActions.js.map